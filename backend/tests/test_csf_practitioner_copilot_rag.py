from fastapi import FastAPI
from fastapi.testclient import TestClient

from src.api.routes.csf_practitioner import router as practitioner_router
import src.api.routes.csf_practitioner as csf_practitioner_route
from src.autocomply.domain.csf_copilot import CsfCopilotResult
from src.autocomply.domain.csf_practitioner import CsDecisionStatus
from src.api.models.compliance_models import RegulatorySource

# Local FastAPI app with the practitioner router mounted
app = FastAPI()
app.include_router(practitioner_router)

client = TestClient(app)

BASE_FORM_PAYLOAD = {
    "facility_name": "Test Dental Practice",
    "facility_type": "dental_practice",
    "account_number": "A123",
    "practitioner_name": "Dr. Test Practitioner",
    "state_license_number": "ST-12345",
    "dea_number": "DEA-1234567",
    "ship_to_state": "OH",
    "attestation_accepted": True,
    "internal_notes": None,
}

STRUCTURED_REASON = (
    "Based on the information provided, Practitioner CSF vertical: it is appropriate to "
    "proceed with shipment."
)


def test_practitioner_copilot_returns_structured_explanation(monkeypatch) -> None:
    """
    When the RAG explainer succeeds, the endpoint should still return the
    structured explanation generated by the explanation builder, not the
    raw RAG answer string.
    """

    async def fake_run_csf_copilot(*args, **kwargs):
        return CsfCopilotResult(
            status=CsDecisionStatus.OK_TO_SHIP,
            reason="rag reason should be overridden",
            missing_fields=[],
            regulatory_references=[],
            rag_explanation="rag explanation",
            artifacts_used=["csf_practitioner_form"],
            rag_sources=[
                RegulatorySource(
                    id="csf_practitioner_form",
                    title="Practitioner CSF",
                    snippet="Mock source",
                )
            ],
        )

    def fake_build_explanation(*args, **kwargs):
        return STRUCTURED_REASON

    monkeypatch.setattr(csf_practitioner_route, "run_csf_copilot", fake_run_csf_copilot)
    monkeypatch.setattr(csf_practitioner_route, "build_explanation", fake_build_explanation)

    resp = client.post("/csf/practitioner/form-copilot", json=BASE_FORM_PAYLOAD)
    assert resp.status_code == 200

    data = resp.json()
    assert data["status"] == "ok_to_ship"
    assert data["reason"] == STRUCTURED_REASON


def test_practitioner_copilot_rag_failure_still_structured(monkeypatch) -> None:
    """
    When the RAG explainer fails, the endpoint should fall back gracefully
    but still return a structured explanation from the explanation builder.
    """

    async def rag_failure_copilot(*args, **kwargs):
        return CsfCopilotResult(
            status=CsDecisionStatus.OK_TO_SHIP,
            reason="fallback rag reason",
            missing_fields=[],
            regulatory_references=[],
            rag_explanation="RAG pipeline fallback",  # Simulate a handled failure
            artifacts_used=[],
            rag_sources=[],
        )

    def fake_build_explanation(*args, **kwargs):
        return STRUCTURED_REASON

    monkeypatch.setattr(csf_practitioner_route, "run_csf_copilot", rag_failure_copilot)
    monkeypatch.setattr(csf_practitioner_route, "build_explanation", fake_build_explanation)

    resp = client.post("/csf/practitioner/form-copilot", json=BASE_FORM_PAYLOAD)
    assert resp.status_code == 200

    data = resp.json()
    assert data["status"] == "ok_to_ship"
    assert data["reason"] == STRUCTURED_REASON
